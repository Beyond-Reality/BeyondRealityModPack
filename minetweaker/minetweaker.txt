MineTweaker is a mod that enables players and server admins to alter recipes (both crafting recipes, furnace recipes and now also some mod machine recipes) as well as changing some small things such as item names, fuel burning times, ... For all these functions, MineTweaker uses a fully scripted language, making it easy to understand and offering a lot of functionality.

Finally I've been able to sort out my build system, which means new features will come out soon.

[b]Usage[/b]: It's a forge mod. Put it in the mods directory and start the game. An empty config file will be generated automatically in the config/minetweaker folder. Edit the file to define the behavior of MineTweaker. Check the in-game command /help minetweaker to get information about the in-game commands available.

[spoiler='READ THIS FIRST if you want to debug your script']
With the 1.6 launcher, debugging your minetweaker script is easy because the launcher contains its own console. MineTweaker prints all its modifications and errors to that console window.

Unfortunately, by default, the launcher closes when the game starts, but you can alter a setting to fix this. To keep the launcher open when the game starts, alter the following setting:[list]
[*]Open your 1.6 launcher
[*]Go to 'edit profile'
[*]Make sure 'launcher visibility' is checked and 'keep the launcher open' is selected
[/list]
Now amongst all the output generated by Forge and the loaded mods, you will find lines starting with Minetweaker telling you what it's doing, which alterations it has made, and which errors have been encountered, if any.
[/spoiler]

[spoiler='Using the mod']
[b][size=5]Scripts[/size][/b]

MineTweaker uses scripts to define its behavior. There are two ways to store scripts:[list]
[*]Local, in a folder called "minetweaker" in the config directory
[*]Server-side, in a folder called "minetweaker" in the savegame directory
[/list]
If local scripts are used, they must be the same between server and client. If server-side scripts are used, they only have to be defined on the server and they will be automatically sent to the client and executed when the client connects. When the client disconnects from the server, any changes made by the server scripts are rolled back. Server-side scripts thus enable custom recipes and values without having to worry about getting them synchronized with the clients.

Local and server scripts both start execution at main.cfg. This file can then include other files in its directory or any of its subdirectories.

In main.cfg, the first statement must be a version statement: "version 2;", which is automatically generated when the mod it started for the first time. If you had a version 1 script, it will be automatically converted to the new script format.

Further statements can then:[list]
[*]Declare new recipes or remove old recipes
[*]Alter the ore dictionary
[*]Set displayed item names
[/list]
[spoiler="Recipes"]
To remove any and all known recipes that result in a certain item, use [font=courier new,courier,monospace]minetweaker.remove[/font]. The following examples all remove the gold block recipe:
[CODE]
minetweaker.remove(tile.blockGold);
minetweaker.remove(<41>);
minetweaker.remove(<35:0>);
[/CODE]

Note that the first command uses the full item name. If you don't know the item name, use the in-game command /minetweaker name <itemid>. (for example [font=courier new,courier,monospace]/minetweaker name 41[/font]). Using item names is recommended as it makes the names independent of the ID assignments.

If an item starts with "tile." (for blocks) or "item." (for items) they can be accessed directly using their full name. (tile.blockGold, for instance). However, mods often have items or blocks with names which do not start with "tile." or "item." . As fallback, all items and blocks, including those starting with "tile." and "item.", can be accessed using the items and blocks values. (for instance, the IC2 rotary macerator is accessible via blocks.blockRotaryMacerator)

[b]Note that item IDs must be placed inside angled brackets[/b]. If not, the scripting engine will recognize it as a number and not as an item ID. You can use simple ids (for example, <41> for the gold block) or id:meta pairs (for example, <35:3> for yellow wool).

Be aware of the difference between item <35> and item <35:0>. The first item denotes any kind of wool block, and running "/minetweaker name 35" will give you tile.cloth, the internal generic name of wool blocks. If using the item (either from its id, <35>, or name, tile.cloth) in a recipe, the recipe will accept any kind of wool, and if using it as an output, it will create item 35:0, which is white wool. Running "/minetweaker name 35:0" will give you tile.cloth.white, which is white wool. Using that in a recipe, the recipe will accept only white wool, but not any kind of colored wool. Also note that when using NEI to look up item IDs, the :0 meta-value will not be shown even though the item really uses ID <XX:0> and not ID <XX>.

You can also go more specific and use the recipes.remove command. For example:
[CODE]recipes.remove(tile.blockGold);[/CODE]

This like of code will remove only crafting recipes, but not, for instance, smelting recipes.

You can even go more specific and remove only shaped or shapeless recipes:
[CODE]recipes.removeShaped(tile.blockGold);
recipes.removeShapeless(tile.blockGold);
[/CODE]

If you really want to remove a specific recipe, that is possible too:
[CODE]
gold = item.ingotGold;
recipes.removeShaped(tile.blockGold, [[gold, gold, gold], [gold, gold, gold], [gold, gold, gold]]);
recipes.removeShapeless(tile.cloth, [tile.cloth, oreDict.dyeYellow]);
[/CODE]

Note that in this example, we assign item.ingotGold to the name gold. This allows me to not having to repeat item.ingotGold every time. Also note the usage of the yellow dye ore dictionary item. Also notes that shaped recipes expect a twodimensional array (each subarray being a row of the crafting recipe) and the shapeless recipes expect a onedimensional array (simply listing the contents of the shapeless recipe, the order of items doesn't matter).

Of course, adding recipes is also possible:
[CODE]
gold = item.ingotGold;
wood = oreDict.plankWood;
recipes.addShaped(tile.blockGold, [[wood, gold, wood], [gold, gold, gold], [wood, gold, wood]]);
recipes.addShaped(gold * 5, [[tile.blockGold]]);
recipes.addShapeless(tile.oreGold, [gold, tile.stone]);
[/CODE]

Note the usage of the "* 5" in the second recipe. This means that the recipe will craft 5 of these items instead of just one.

These multipliers can also be used in the remove commands. By default, a remove command doesn't care how many items are crafted with the recipe. However, with the multiplier, a remove command becomes sensitive to the amount of items crafted:
[CODE]
minetweaker.remove(item.ingotGold * 9);
[/CODE]
This instruction will remove only the ore to ingots recipe, but not, for instance, the gold ingot smelting recipe. Similarly, minetweaker.remove(item.ingotGold * 1) would only remove the gold ingot smelting recipe but not the block to ingot recipe.

You can also do stuff like this:
[CODE]
anyWood = oreDict.plankWood.any;
recipes.removeShaped(<*>, [[anyWood, null, null], [anyWood, anyWood, null], [anyWood, anyWood, anyWood]]);
[/CODE]
This instruction will remove all stairs recipes.

Why did we use oreDict.plankWood.any and not just oreDict.plankWood? Using oreDict.plankWood would only match recipes that use the ore dictionary as their recipe contents. However, the stairs recipes are defined for specific wood types (birth, oak, ...) and thus would not match. With oreDict.plankWood.any we specify that we want any kind of wood to match, and not just the plankWood oredictionary entry. Similarly, using remove with oreDict.plankWood.any will remove all recipes that craft any kind of wood.

Also not the wildcard value <*>. This means: "match any item". Doing minetweaker.remove(<*>) would, for example, make all items uncraftable.

What about subitems? Most of the time, subitems are handled transparently for you, but sometimes you need to do subitem work. A subitem is automatically created when you load it by its name, for instance:
[CODE]
recipes.remove(tile.cloth.orange); # will remove orange wool crafting recipe
recipes.remove(tile.cloth); # will remove all wood crafting recipes
recipes.remove(<35:4>); # will remove yellow wool crafting recipe
[/CODE]
Likewise, using tile.cloth as recipe ingredient will allow any color of wool to be used. Using tile.cloth.white, for instance, would only allow white wool to be used.

Since version 2.2.2, it is also possible to craft damaged items:
[CODE]
recipes.addShaped(item.pickaxeWood.withDamage(1), ...recipe...);
[/CODE]

Now you are able to make your own recipes. But what if your output items should have their damage or NBT tags set? Now this is possible with crafting functions. Consider the following statement:
[CODE]
recipes.addShapeless(item.pickaxeWood, [item.pickaxeWood.damaged, item.axeWood.damage], function(output, input) {
output.damage = max(0, output.maxDamage - (input[0].maxDamage - input[0].damage) - (input[1].maxDamage - input[1].damage) - output.maxDamage * 0.1);
});
[/CODE]
This will make wooden pickaxe repairable by combining it with a wooden axe. Now, this example may not be very interesting, but this functionality makes it possible to add repair recipes in case your favorite mod forgot to include them. Also notice the usage of item.damaged: by default, damaged items cannot be used as crafting ingredients, but using .damaged enables the use of damage items as well.

Now we can also make it more interesting. You can also set NBT tags with these functions. This recipe crafts awesome gold ingots:
[CODE]
recipes.addShapeless(item.ingotGold, [item.ingotGold, item.ingotIron], function(output, input) {
    output.tag = {
        "display": { "Name": "Awesome gold ingot" }
    };
});
[/CODE]
Now when you craft a gold and iron ingot together, it will create a gold ingot with the name "Awesome gold ingot" as if you set the name using the anvil.

This can be used for anything that uses NBT tags. For example, enchantments:
[CODE]
recipes.addShapeless(item.pickaxeDiamond, [item.pickaxeDiamond, item.netherStar], function (output, input) {
    output.tag = {
        "RepairCost": 2,
        "ench": [
            {"id": 33 as short, "lvl": 1 as short }
        ]
    };
});
[/CODE]
Combining a diamond pickaxe with a nether stack now gives a silk touch diamond pickaxe! Notice the "as short" after the values. Enchantment id and levels require short values, but by default integer constants are int values, thus they need to be converted. If you were to omit the conversions, it would store it as an int, and crash the game.

This functionality can also be used to define mod item recipes that would otherwise be uncraftable. Just use an NBT editor to descover the structure of the item and replicate that structure exactly in you crafting recipes. (note: if you need a byte array, "as byte[]" will give that. Using "as int[]" will give an int array. [1, 2] will result in a list tag. [1, 2] as int[] will result in an int array tag)
[/spoiler]

[spoiler="Furnace"]
Furnace recipes can also be removed:
[CODE]
furnace.remove(item.ingotGold);
[/CODE]
This will remove the gold ingot smelting recipe.

You can also go more specific with the removeRecipe method:
[CODE]
furnace.removeRecipe(item.ingotGold, tile.oreGold);
[/CODE]
which does the same.

Adding furnace recipes works too:
[CODE]
furnace.remove(item.ingotGold);
furnace.addRecipe(item.ingotGold * 2, tile.oreGold);
[/CODE]
And voila, now gold ore gives you two gold ingots instead of one.

But now it doesn't give any XP anymore. No problem, since that can be fixed easily by altering our code a little bit:
[CODE]
furnace.remove(item.ingotGold);
furnace.addRecipe(item.ingotGold * 2, tile.oreGold, 1.0);
[/CODE]
Now you get some xp too. The latter value can be modified to give more or less xp.

It is also possible to add and remove furnace fuels as well as changing existing fuels, all with one simple statement:
[CODE]
tile.leaves.fuel = 40;
[/CODE]

Remember when you used to burn dry leaves as kid and have it burn in a strong and quick flame? Now you can do it in minecraft furnaces too! In this example, it will burn for 40 ticks (2 seconds) so you better have some supply available if you want to use it as fuel.

Setting an item's fuel value to 0 will make it no longer work as fuel. It is also possible to use oreDict.xx.any values to make all items from that entry burnable. If a value is set for both a specific item as well as its ore dictionary value, the item-specific value will take precedence.
[/spoiler]

[spoiler="Ore Dictionary"]
Unless you skipped the first spoilers, you should already know how to use ore dictionary entries and ore dictionary .any values. But it's also possible to alter the ore dictionary, and quite easily so:

[CODE]
oreDict.plankWood.add(tile.leaves);
[/CODE]
Now leaves can magically be used as wood too. Handy if your mod forgot to add its custom wood to the ore dictionary.

It's also possible to define new ore dictionary items simply by using an ore dictionary name that doesn't exist yet:
[CODE]
oreDict.myAnyIngot.add(item.ingotGold);
oreDict.myAnyIngot.add(item.ingotIron);
[/CODE]

Items can be removed too:
[CODE]
oreDict.plankWood.remove(tile.wood);
[/CODE]
Now, this example may not be very practical, but I can sure imagine cases where you find certain recipe item alternatives too cheap and want them removed.
[/spoiler]

[spoiler="Item names"]
If an item happens to be missing its name, or you don't like the item name, it can be changed easily:
[CODE]
item.ingotIron.displayName = "The Iron Ingot";
item.ingotIron.setDisplayName("The Iron Ingot"); # does the same
[/CODE]

Or, if you want to go international:
[CODE]
item.ingotIron.setDisplayName("nl_NL", "De ijzeren ingot"); # sets the item name for Dutch translation
[/CODE]
[/spoiler]

[spoiler="Liquids"]
MineTweaker now also has support for liquids. These liquids are used in certain mods, such as buildcraft fuels or the refinery recipes.

Liquid values can be obtained through their source block ID or name:
[CODE]
print(tile.water.displayName);
[/CODE]

They can also be obtained through their container:
[CODE]
print(item.bucketLava.liquid.displayName);
print(<293>.liquid.displayName);
[/CODE]

They can also be obtained through their registered name:
[CODE]
print(fluid.tile.water.displayName);
[/CODE]
If their name does not start with fluid., they can be obtained from fluids just like items and blocks can be used to retrieve items with non-standard names. Their name can be retrieved with the command /minetweaker liquid <containerItemId> or /minetweaker liquid <sourceBlockId>.

Liquid containers can be added or removed this way:
[CODE]
lavaLiquid = item.bucketLava.liquid;
lavaLiquid.addContainer(tile.cobblestone, 0.1, tile.hellrock); # registers netherrack as cobblestone containing 0.1 buckets of lava
lavaLiquid.removeContainer(item.bucketLava);
[/CODE]
Now try putting netherrack in a liquid transposer - it can take a bit of lava out of the netherrack. The lava bucket, however, won't work anymore.

In minecraft 1.6.2, additional fields are available:
[CODE]
print(fluid.tile.water.temperature);
print(fluid.tile.water.density);
print(fluid.tile.water.luminosity);
print(fluid.tile.water.gaseous);
[/CODE]
These fields are settable too. In minecraft 1.5.2, reading them results in zero and setting them does nothing other than printing a warning.
[/spoiler]

[spoiler="Server scripts and clear()"]
When minetweaker starts, it will first execute the scripts in its config/minetweaker directory. When the player joins the server (or the server starts) it will then execute
the scripts from the server's savegame minetweaker directory. By default, these changes will supplement the changes already made. It is possible to undo the modifications that have been made before with the minetweaker.clear command:
[CODE]
minetweaker.clear(): # undoes all modifications done so far
[/CODE]

However, although all non-mod modifications can be undone, it will not always be possible to do so. Some mods have alterations that cannot be rolled back. When any such modification has been performed, it will break the clear function (and generate an exception). Additionally, when such permanent modification is executed in a server script, the player will have to restart minecraft to join another game. The player can still rejoin the same game as long as the server scripts haven't changed.

To check if clear() will work, wrap it in a canClear test:
[CODE]
if (minetweaker.canClear()) {
minetweaker.clear();
} else {
# do stuff in case we can't clear
}
[/CODE]
[/spoiler]

[spoiler="Multifile scripts"]
Scripts start execution at main.cfg. Other files can be put in minetweaker directories and although not executed by default, can be included with include statements:
[CODE]
include "subfile.cfg";
[/CODE]

This will include the file names "subfile.cfg" and execute its contents. The variables created by this file will be accessible when the file exist. If you do not want such behavior you can wrap the include in a block statement:
[CODE]
{
    include "subfile.cfg";
}
[/CODE]

Note, however, that subfile.cfg can still change existing variables.

Subdirectories can be created and files loaded from them:
[CODE]
include "subdir/subfile.cfg";
[/CODE]

Scripts cannot include files outside the minetweaker directory. Note that servers will send all the files in their minetweaker directory (and subdirectories) to the client, even if not used.
[/spoiler]

[spoiler="Mod Support"]
Currently MineTweaker has mod integration support with BuildCraft, IndustrialCraft 2, GregTech and Forestry. Most of the machines can have recipes added to them, sometimes recipes can be removed as well.

Keep in mind that not all actions can be undone. If an action in a server-side script is not undoable, the server must restart the game in order to join another game with a different script. (or if the game had its scripts changed) Actions that cannot be undone are marked and a warning will be generated in the console when such action is executed.

[spoiler="BuildCraft"]
It is now possible to alter the assembly table recipes and alter refinery recipes, as well as defining new engine fuels and coolants.

Adding or removing an assembly table recipe is pretty easy:
[CODE]
modSupport.buildcraft.assemblyTable.addRecipe(item.netherStar, 100000, [item.diamond, item.skull.wither]);
modSupport.buildcraft.assemblyTable.remove(item.pipeGateAutarchic.0);
modSupport.buildcraft.assemblyTable.removeRecipe(<*>, [item.redstone, item.redstoneChipset.3]); # removes diamond gate recipes
modSupport.buildcraft.assemblyTable.setEnergy(item.redstoneChipset.2, 1000); # make golden chipset pretty cheap energy-wise
[/CODE]
The second argument to addRecipe is the energy cost in MJ. (in comparison: the redstone to redstone chipset recipe costs 10000MJ) Remove and RemoveRecipe work just like all the other ones present in MineTweaker and item patterns will work just fine. Note that ore dictionary entries cannot be used at assembly table recipe items.

The refinery can also be customized to process the liquids you like:
[CODE]
modSupport.buildcraft.refinery.addRecipe(tile.lava, 12, 1, tile.water); # converts water to lava
modSupport.buildcraft.refinery.remove(item.bucketFuel.liquid);
[/CODE]
Putting water in the refinery will now convert it to lava. It will take 1 tick for 1 millibucket and consume 12 MJ per millibucket. RemoveRecipe will work as well.

It's also possible to have the refinery take two different liquids and convert them to another liquid. To do so, add another liquid as argument to the addRecipe function.

Fuels can be added and removed too, as well as some other things:
[CODE]
modSupport.buildcraft.fuels.add(tile.water, 1, 1000); # make water generate 1MJ/cycle for 1000 cycles
modSupport.buildcraft.fuels.remove(item.bucketOil.liquid); # oil doesn't work as fuel anymore
print(modSupport.buildcraft.fuels[tile.water].liquid.displayName);
print(modSupport.buildcraft.fuels[tile.water].powerPerCycle);
print(modSupport.buildcraft.fuels[tile.water].totalBurningTime);
[/CODE]
The fields powerPerCycle and totalBurningTime are also settable.

For the buildcraft filler, "soft" blocks can be removed by the filler (without dropping anything). Soft blocks can be added or removed with minetweaker:
[CODE]
modSupport.buildcraft.setSoftBlock(tile.water, true);
modSupport.buildcraft.setSoftBlock(tile.grass, false);
[/CODE]
Now the filler will automatically remove still water blocks, but not grass blocks.
[/spoiler]

[spoiler="IndustrialCraft 2"]
The IC2 mod support interface supports the addition and removal of the compressor, extractor and macerator recipes:
[CODE]
modSupport.ic2.macerator.remove(tile.sand); # remove the cobble -> sand maceration
modSupport.ic2.macerator.removeRecipe(item.ironDust, item.ironOre); # removes the iron ore -> iron dust recipe
modSupport.ic2.macerator.addRecipe(tile.sand * 4, tile.sandstone); # macerates sandstone into 4 sand
[/CODE]
The three methods (remove, removeRecipe and addRecipe) are available for each of the three machines.

In Minecraft 1.6, only the addRecipe method is available. Recipes cannot be removed due to the API limitations. In 1.6, IC2 machines also support ore dictionary values. In Minecraft 1.5, ore dictionary values cannot be used in machine recipes.

The new machines are also available:
[CODE]
modSupport.ic2.metalFormer.cutting.addRecipe(output, input);
modSupport.ic2.metalFormer.rolling.addRecipe(output, input);
modSupport.ic2.metalFormer.extruding.addRecipe(output, input);
modSupport.ic2.centrifuge.addRecipe([output1, output2, output3], input, minHeat);
modSupport.ic2.oreWashingPlant.addRecipe([output1, output2, output3], input);
modSupport.ic2.oreWashingPlant.addRecipe([output1, output2, output3], input, millibucketsOfWater);
[/CODE]
[/spoiler]

[spoiler="GregTech"]
All GregTech machines are supported, in all versions. However, recipes can only be added, never removed. For all the machines, the duration is measured in ticks (1 second = 20 ticks) and energy consumption in EU per tick. None of the gregtech functions are undoable!

Be aware that GregTech doesn't support ore dictionary values in its machine recipes.

Alloy smelter:
[CODE]
modSupport.gregtech.alloySmelter.addRecipe(output, input1, input2, duration, euPerTick);
[/CODE]

Assembler:
[CODE]
modSupport.gregtech.assembler.addRecipe(output, input1, input2, duration, euPerTick);
modSupport.gregtech.assembler.addRecipe(output, input, null, duration, euPerTick);
[/CODE]

Blast furnace:
[CODE]
modSupport.gregtech.blastFurnace.addRecipe(output, input1, input2, duration, euPerTick, minimumHeat);
modSupport.gregtech.blastFurnace.addRecipe(output, input, null, duration, euPerTick, minimumHeat);
[/CODE]

Canner:
[CODE]
modSupport.gregtech.canner.addRecipe(output, input);
modSupport.gregtech.canner.addRecipe(output, input1, input2);
modSupport.gregtech.canner.addRecipe(output, input1, input2, duration);
modSupport.gregtech.canner.addRecipe(output, input1, input2, duration, euPerTick);
modSupport.gregtech.canner.addRecipe(output, input, null, duration);
modSupport.gregtech.canner.addRecipe(output, input, null, duration, euPerTick);
[/CODE]
By default, canning takes 100 ticks at 1 EU/tick.

Chemical reactor:
[CODE]
modSupport.gregtech.chemical.addRecipe(output, input1, input2, duration);
[/CODE]

Cutter:
[CODE]
modSupport.gregtech.cutter.addRecipe(output, input, duration, euPerTick);
[/CODE]

Distillation tower:
[CODE]
modSupport.gregtech.distillationTower.addRecipe([output1, output2, output3, output4], input, cells, duration, euPerTick);
[/CODE]
The distillation tower can have 1-4 outputs.

Electrolyzer:
[CODE]
modSupport.gregtech.electrolyzer.addRecipe([output1, output2, output3, output3], input, numCells, duration, euPerTick);
[/CODE]
The electrolyzer can have 1-4 outputs.

Fusion reactor:
[CODE]
modSupport.gregtech.fusionReactor.addRecipe(output, input1, input2, duration, energyPerTick, startupEnergy);
[/CODE]

Implosion compressor:
[CODE]
modSupport.gregtech.implosionCompressor.addRecipe(output, input, itnt);
modSupport.gregtech.implosionCompressor.addRecipe([output1, output2], input, itnt);
[/CODE]
The implosion compressor has an optional byproduct. You don't need the array notation if there is no such byproduct.

Industrial centrifuge:
[CODE]
modSupport.gregtech.centrifuge.addRecipe([output1, output2, output3, output3], input, numCells, duration);
modSupport.gregtech.centrifuge.addRecipeFuelCan([output1, output2, output3, output4], input, duration);
[/CODE]
The industrial centrifuge can have 1-4 outputs. AddRecipe will add a regular recipe, taking zero or more tin cells. AddRecipeFuelCan fills a fuel can when centrifuging. The fuel can must then be replaced with a new one.

Industrial grinder:
[CODE]
modSupport.gregtech.grinder.addRecipe(output, input);
modSupport.gregtech.grinder.addRecipe([output1, output2, output3, output4], input);
modSupport.gregtech.grinder.addRecipe(output, input1, input2);
modsupport.gregtech.grinder.addRecipe([output1, output2, output3, output4], input1, input2);
[/CODE]
The grinder can take 1 or 2 inputs and can produce 1-4 outputs. If there is only one output, the array notation can be skipped.

Lathe:
[CODE]
modSupport.gregtech.lathe.addRecipe(output, input, duration, euPerTick);
modSupport.gregtech.lathe.addRecipe([output1, output2], input, duration, euPerTick);
[/CODE]
The lathe can produce 1 or 2 outputs. If there is only one output, the array notation can be skipped.

Plate bender:
[CODE]
modSupport.gregtech.plateBender.addRecipe(output, input, duration, euPerTick);
[/CODE]

Sawmill:
[CODE]
modSupport.gregtech.sawmill.addRecipe(output, input);
modSupport.gregtech.sawmill.addRecipe([output1, output2, output3, output4], input);
modSupport.gregtech.sawmill.addRecipe(output, input, cells);
modsupport.gregtech.sawmill.addRecipe([output1, output2, output3, output4], input, cells);
[/CODE]
The sawmill can produce 1-4 outputs and may or may not take water cells. If there is only 1 output, the array notation can be skipped.

Vacuum freezer:
[CODE]
modSupport.gregtech.vacuumFreezer.addRecipe(output, input, duration);
[/CODE]

Wiremill:
[CODE]
modSupport.gregtech.wiremill.addRecipe(output, input, duration, euPerTick);
[/CODE]

It is also possible to add new fuels to the different kinds of generators:
[CODE]
modSupport.gregtech.dieselGenerator.addFuel(item, euPerMillibucket);
modSupport.gregtech.dieselGenerator.addFuel(item, euPerMillibucket, output);
modSupport.gregtech.gasTurbine.addFuel(item, euPerMillibucket);
modSupport.gregtech.gasTurbine.addFuel(item, euPerMillibucket, output);
modSupport.gregtech.thermalGenerator.addFuel(item, euPerMillibucket);
modSupport.gregtech.thermalGenerator.addFuel(item, euPerMillibucket, output);
modSupport.gregtech.denseFluidGenerator.addFuel(item, euPerMillibucket);
modSupport.gregtech.denseFluidGenerator.addFuel(item, euPerMillibucket, output);
modSupport.gregtech.plasmaGenerator.addFuel(item, euPerMillibucket);
modSupport.gregtech.plasmaGenerator.addFuel(item, euPerMillibucket, output);
modSupport.gregtech.magicGenerator.addFuel(item, euPerMillibucket);
modSupport.gregtech.magicGenerator.addFuel(item, euPerMillibucket, output);
[/CODE]
If the item is a liquid container, it will fill the generator with the content of the container and generate the set amount of EU per millibucket of liquid. Additionally, if the item is a liquid container, the generator may also accept liquids of that type. If the item is not a liquid container, it will generate the equivalent of 1 bucket (= 1000 millibuckets).
[/spoiler]

[spoiler="Forestry"]
Recipes can be added to the forestry machines, but not removed. Additionally, recipe alterations cannot be undone, meaning that the client will have to be restarted to join another game.

Bees: bee genes can be blacklisted
[CODE]
modSupport.forestry.bees.blacklist("the.internal.gene.name");
[/CODE]
If you, like most people, don't know the full internal name of the gene, you can print the list of genes to the development console:
[CODE]
modSupport.forestry.bees.printGenes();
[/CODE]
Make sure to keep the development console open to see the output - see instructions on the beginning of this post. You should recognize your gene in the list. You can blacklist any gene. If a gene is blacklisted, it cannot be obtained through mutation.

Biogas engine: fuels can be added and removed
[CODE]
modSupport.forestry.biogasEngine.addFuel(liquid, powerPerCycle, burnDuration);
modSupport.forestry.biogasEngine.addFuel(liquid, powerPerCycle, burnDuration, heatFactor);
modSupport.forestry.biogasEngine.removeFuel(liquid);
[/CODE]
powerPerCycle provides the amount of energy per engine stroke. BurnDuration is expressed in the number of engine strokes. HeatFactor can be used to heat up the engine more quickly.

Biogenerator: fuels can be added or removed
[CODE]
modSupport.forestry.bioGenerator.addFuel(liquid * amount, euPerTick, ticksPerMillibucket);
modSupport.forestry.bioGenerator.removeFuel(liquid);
[/CODE]

Carpenter: recipes can be added
[CODE]
modSupport.forestry.carpenter.addRecipe(output, [[input11, input12, input22], [input21, input22, input23], [input31, input32, input33]]);
modSupport.forestry.carpenter.addRecipe(output, [[recipe]], box);
modSupport.forestry.carpenter.addRecipe(output, [[recipe]], box, time);
modSupport.forestry.carpenter.addRecipe(output, [[recipe]], box, time, liquid * amountOfMillibuckets);
[/CODE]
The recipe input can be any valid recipe input, including ore dictionary entries. The box parameter can be null and makes the recipe require a certain container. The input recipe can be any size from 1x1 to 3x3 but must always be a twodimensional array.

Centrifuge: recipes can be added
[CODE]
modSupport.forestry.centrifuge.addRecipe(output, input, time);
modSupport.forestry.centrifuge.addRecipe([output1, output2, ...], input, time);
modSupport.forestry.centrifuge.addRecipe([output1, output2, ...], input, time, [probability1, probability2, ...]);
[/CODE]
A centrifuge may output any number of items. If no item probabilities are provided, they are assumed to be 100%. If there are more items than probabilities, the remaining items will be generated with a probability of 100%. If there are more probabilities than items, they will be ignored. The centrifuge does not support ore dictionary entries for its input.

Fabricator: it is possible to add new recipes, both with existing and new liquids. New items can be specified to be smelted into liquids internally.
[CODE]
modSupport.forestry.fabricator.addRecipe(output, [[inputRecipe]], liquid);
modSupport.forestry.fabricator.addRecipe(output, [[inputRecipe]], liquid, castItem);
modSupport.forestry.fabricator.addSmelting(liquid * amountInMillibuckets, item, meltingPoint);
[/CODE]
The input recipe can be a 1x1 to 3x3 twodimensional array, just like shaped recipes. The recipe items can be items or ore dictionary entries. Recipes may or may not require a cast.

Fermenter: new recipes can be added, as well as new fuels for fermentation.
[CODE]
modSupport.forestry.fermenter.addRecipe(output, input, outputValue);
modSupport.forestry.fermenter.addRecipe(output, input, outputValue, modifier);
modSupport.forestry.fermenter.addRecipe(output, input, outputValue, modifier, inputLiquid * amount);
modSupport.forestry.fermenter.addFuel(item, fermentPerCycle, cycles);
modSupport.forestry.fermenter.removeFuel(item);
[/CODE]
The modifier value can increase the amount of fermented output generated. The input liquid can make the fermenter accept liquid as well.

Moistener: new recipes can be added as well as new fuels for moistening.
[CODE]
modSupport.forestry.fermenter.addRecipe(output, input, time);
modSupport.forestry.fermenter.addFuel(fuelItem, output, moistenerValue, stage);
modSupport.forestry.fermenter.removeFuel(fuelItem);
[/CODE]
The stage value indicates the priority of the fuel items: items with a lower stage value will be consumed first.

Peat-fired engine: fuels can be added or removed
[CODE]
modSupport.forestry.peatFiredEngine.addFuel(item, powerPerCycle, numCycles);
modSupport.forestry.peatFiredEngine.removeFuel(item);
[/CODE]

Rainmaker: rainmaking and rain-stopping items can be added or removed:
[CODE]
modSupport.forestry.rainmaker.addRainItem(item, duration, speed);
modSupport.forestry.rainmaker.addStopItem(item, duration, speed);
modSupport.forestry.rainmaker.removeItem(item);
[/CODE]
Speed indicates how fast the rain starts or stops. Duration indicates the amount of ticks the rain will last.

Squeezer: new recipes can be added
[CODE]
modSupport.forestry.squeezer.addRecipe(output, input, time);
modSupport.forestry.squeezer.addRecipe(output, [input1, input2, ...], time);
modSupport.forestry.squeezer.addRecipe(output, input, time, remnant);
modSupport.forestry.squeezer.addRecipe(output, [inputs], time, remnant);
modSupport.forestry.squeezer.addRecipe(output, input, time, remnant, remnantChance);
modSupport.forestry.squeezer.addRecipe(output, [inputs], time, remnant, remnantChance);
[/CODE]
The squeezer recipes accept one ore more inputs. If there is only one input, the array notation can be skipped. Stack sizes are taken into account. Recipes can have a remaining item and a 1-100 value representing the chance of retrieving it.

Still: new recipes can be added
[CODE]
modSupport.forestry.still.addRecipe(output, input, cyclesPerUnit);
[/CODE]
[/spoiler]
[/spoiler]

[spoiler="Modding API"]
MineTweaker can be very handy to allow users to make certain modifications to a mod. With server scripts, it can enable server admins to make changes to a mod's behaviour without having to distribute new config files. It is possible for mods to make use of this functionality by providing MineTweaker with a mod interface.

To get started developing mods, use the source distribution of MineTweaker, which can be downloaded from my [url="https://github.com/stanhebben/MineTweaker"]GitHub repository[/url].
(the code is all rights reserved, alteration and redistribution is not permitted and is supplied for the sole purpose of implementing mod apis. in future I may apply a more liberal license for the source code)

To implement a mod interface, you should create an instance or subclass of stanhebben.minetweaker.api.MineTweakerInterface and register it with the static Tweaker.registerModInterface method during the init phase of your mod.  This interface should return a TweakerValue instance. It is best to subclass TweakerValue and implement the index(String) method and have it return TweakerFunction instances that implement your functions or Tweaker values if you need getters. (see the stanhebben.minetweaker.api.values package for all possible value classes)

As the doc comments clearly indicate, make sure to wrap every alteration in a IUndoableAction instance and supply those to the Tweaker.apply method, which will execute the action. If you don't, your alterations will be permanent even if used in server scripts, which is bad since it will mess up as soon as the user would join another server or a single player game.

PM me if you are a mod developer and need further help with this. Only make use of the classes in the api packages, as everything else is subject to change. Don't include my files in your mod! It's not necessary to include any file as long as you first check if minetweaker is loaded (the mod id is "MineTweaker") before registering your mod interface.
[/spoiler]
[/spoiler]

[spoiler="Changelog"]
[size=4]Version 2.2.3[/size][list]
[*]Fixed the wiremill recipes switching input and output
[*]Fixed removing items from the ore dictionary
[/list]
[size=4]Version 2.2.2[/size][list]
[*]added withDamage function for items, providing a craftable damaged item that works anywhere
[*]printed item names are now printed exactly as they have to be formatted in code
[*]fixed GregTech support in 1.5.2 not loading properly
[*]fixed IC2 centrifuge; can now set the minimum heat required
[/list]
[size=4]Version 2.2.1[/size][list]
[*]Fixed NPE when using a recipe added to the ore washing plant
[*]Can now adjust the amount of water used in the ore washing plant
[/list]
[size=4]Version 2.2.0[/size][list]
[*]GregTech machines are now supported
[*]Forestry machines are now supported
[*]Added the ore washing plant
[*]Can now use <id:*> to denote "any meta value" in a recipe. <id> will still have the same meaning.
[/list]
[size=4]Version 2.1.2[/size][list]
[*]IC2 support extended for versions 1.6.2 and 1.6.4
[*]1.6.4 version added
[*]Fixed a bug with function recipes
[*].only modifier added, enabling input checks
[*]Function recipes can now return false to disable crafting
[/list]
[size=4]Version 2.1.1[/size][list]
[*]Fixed NPE when an empty MineTweaker packet is received
[/list]
[size=4]Version 2.1.0[/size][list]
[*]Liquid support
[*]Liquid container support
[*]BuildCraft support: change assembly table recipes, change refinery recipes, change fuels and coolants
[*](1.5.2 only) IC2 support: add and remove compressor, extractor and macerator recipes
[*]Furnace now supports ore dictionary entries for recipe input
[*]Improved logging system
[*]Now logs the actions that are being performed
[*]Non-undoable actions can now be used on servers. If the player attempts to join another server (or singleplayer game) after such action, the game will request a restart.
[*]Fix for specific furnace recipe removal not working
[*]Fix for errors printing a strange string instead of the script filename
[/list]
[size=4]Version 2.0.3[/size][list]
[*]Added furnace.remove
[*][size=4]Added a ton of checks to print meaningful error messages instead of crashing[/size]
[*][size=4]Fix for dedicated server crash (somewhat experimental but should work)[/size]
[/list]
Version 2.0.2[list]
[*]Fixed a crash with blocks that have no name registered for them
[*]Fixed a potential minor bug preventing the registration of certain items in the name tables
[/list]
Version 2.0.1[list]
[*]Fixed a crash with blocks that have no item registered for them
[/list]
Version 2.0.0[list]
[*]Almost entirely rewritten
[*]Now uses fully scripted files. Script version is now 2.
[*]Old script files are automatically converted to the new system.
[*]Now has two ways of storing script files: inside the config or with the world
[*]Script files stored with the world will be transmitted to all clients when they connect with the server
[*]Script files received from the server will be executed upon connection, and the changes will be undone when disconnecting
[*]Multiple script files can be used, they are stored in the minetweaker directory (in the config / savegame)
[*]Recipes can now have a modification function, enabling damage and NBT tags to be modified or copied from ingredients
[*]Mod API: mods can provide their own interface to MineTweaker
[*]Clear function can undo all modifications made (handy to start a server with)
[/list]
Version 1.1.4[list]
[*]Fixed setName and setLocalizedName for items with meta values
[/list]
Version 1.1.3[list]
[*]Added the setName and setLocalizedName commands
[/list]
Version 1.1.2[list]
[*][size=4]Fixed display of the meta value of wildcard ore dictionary entries[/size]
[*][size=4]Fixed a bug where remove patterns containing ore dictionary entries would not work[/size]
[/list]
Version 1.1.1[list]
[*]Can now set the burning time of mod items, or add new furnace fuels. Does not work with vanilla fuels.
[*]Server command is added to see the fuel value of an item. Reports if the value cannot be altered.
[/list]
Version 1.1.0[list]
[*]Ore dictionary names can now be loaded
[*]Ore dictionary values can be used in shaped and shapeless recipes
[*]Ore dictionary values can be used in recipe patterns
[*]The ~ operator has been added for use in patterns
[*]Ore dictionary entries can be added and removed
[*]Server commands are added to view the ore dictionary contents
[*]Server command is added to see a list of all recipes for a specific item
[*]Server command is added to see the item name for a specific item id (will be used in a future version)
[*]Fixed the removal of shapeless recipes
[/list]
Version 1.0.1[list]
[*]No more example file is generated, fixing the NullPointerException on initial startup.
[/list]
Version 1.0.0[list]
[*]Initial release
[/list]
[/spoiler]

Downloads:[list]
[*]Version 2.2.3 for minecraft 1.5.2 can be downloaded here: [url="https://www.dropbox.com/s/w4fmijsuhwolu59/zMineTweaker-1.5.2-2.2.3.zip"]dropbox link[/url]
[*]Version 2.2.3 for minecraft 1.6.2 can be downloaded here: [url="https://www.dropbox.com/s/n9of10j2kna33jp/zMineTweaker-1.6.2-2.2.3.zip"]dropbox link[/url]
[*]Version 2.2.3 for minecraft 1.6.4 can be downloaded here: [url="https://www.dropbox.com/s/kie4ad15mwge2fg/zMineTweaker-1.6.4-2.2.3.zip"]dropbox link[/url]
[/list]
[spoiler="Copyright and permissions"]
This document is the intellectual property of the author, Stan Hebben. It may be not be reproduced under any circumstances except for personal, private use as long as it remains in its unaltered, unedited form. It may not be placed on any web site or otherwise distributed publicly without advance written permission. Use of this mod on any other website or as a part of any public display is strictly prohibited, and a violation of copyright.

Permissions and modpacks: free to use in modpacks as long as no money is generated from the modpack downloads. (this includes, but is not limited to, adfly links) I am always glad to hear about how you use the mod, but it's not a requirement.
[/spoiler]

[spoiler="Known bugs + planned features"]
Known bugs:[list]
[*]Sometimes removing recipes for IC2 machines doesn't work. This seems caused by IC2 code.
[*]Assembly table recipes added by server scripts don't show up in NEI. This seems a NEI problem.
[*]In 1.6.2 and 1.6.4, server scripts can't alter item names.
[/list]
Planned features: (in order of priority)[list]
[*]Minefactory Reloaded support (being worked on now)
[*]Railcraft support
[*]ThaumCraft 3 support in 1.5.2
[*]ThaumCraft 4 support in 1.6.2 and 1.6.4, as soon as ThaumCraft 4 is released
[*]Thermal Expansion support (hope they have a 1.6 version up at some point)
[*]Recipe ingredients requiring specific NBT tags (almost done now!)
[*]Ability to use ore recipes even in machines where ore recipes are not natively supported
[*]Recipes with reusable items, when I find out how (will be possible with function recipes)
[*]Fixing server script item name changing in 1.6.2 and 1.6.4
[*]Creating a wiki for MineTweaker with all the explanations
[*]Improving the scripting language and releasing a full explanation of all the features
[*]A replace functionality, replacing items with other (possibly ore) items
[/list]
[/spoiler]

If you encounter any bugs, please report them here. Due to the sheer amount of new machines I had no time to test them all, so tell me if something doesn't work quite as it should. If you have feature requests, please post them here too and I will consider them.